\SetKwProg{for}{for}{:}{end}
\SetKwProg{pgsgd}{PG-SGD}{:}{end}
\SetKwProg{each}{for each}{:}{end}
\SetKwProg{IF}{if}{:}{end}

\SetKwFunction{PathIndex}{PathIndex}
\SetKwFunction{RandomLayout}{RandomLayout}
\SetKwFunction{InitZipf}{InitZipf}
\SetKwFunction{Unif}{Unif}
\SetKwFunction{Zipf}{Zipf}
\SetKwFunction{StepCount}{StepCount}
\SetKwFunction{PathId}{PathId}
\SetKwFunction{StepPos}{StepPos}

\begin{algorithm}
	\pgsgd{\textbf{(}$\mathcal{V}$\textbf{)}}{
		\textbf{input:} variation graph $\mathcal{V} = (\mathcal{N}, \mathcal{E}, \mathcal{P})$ \\
		%https://tex.stackexchange.com/questions/22643/how-to-write-letters-in-bold-in-the-math-mode
		\textbf{output:} $k$-dimensional layout $\mathcal{L}$ with $n$ nodes \\
		$\mathcal{XP}$ $\gets \PathIndex(\mathcal{V})$ \tcp{index for efficient path position lookup}
		%\boldsymbol{$Z$} $\gets ZipfZetas(G,P)$ \\ %@Andrea is this correct like this?
		$\mathcal{L}$ $\gets \RandomLayout(n, k)$ \tcp{only 2D PG-SGD has a random layout initialization, 1D starts with the current node order}
		$\mathcal{Z} \gets \InitZipf(\mathcal{V},\mathcal{XP})$ \tcp{generate Zipfian distribution}
		% atomic positions initialization?
		% TODO for somplicity reasons I would only describe the 2D one here
		\for{$\eta$ $in$ $annealing$ $schedule$}{ %our "schedule" actually is the number paths.... we should specify this I would say
			\each{$planned$ $term$ $updates$} { % I think we can remove i<j, because we don't care about that
				$ps_a \gets \Unif(\mathcal{XP})$ \tcp{uniform path step from all steps}
				$path \gets \PathId(ps_a,\mathcal{XP})$ \tcp{the path id of the sampled step}
				\uIf{$(coolling$ $||$ $flip)$} {
					$ps_b \gets \Unif(\StepCount(path, \mathcal{XP}))$ \tcp{uniform path step from specific path}
					$p_b \gets \StepPos(ps_b)$ \tcp{nucleotide position of step}
				} \Else {
					$ps_b \gets \Zipf(path)$ \tcp{Zipfian path step from specific path}
				}
				$p_a \gets \StepPos(ps_a)$ \tcp{nucleotide position of step}
				$p_b \gets \StepPos(ps_b)$ \tcp{nucleotide position of step}
				$nd \gets ||p_a - p_b||$ \tcp{calculate nucleotide distance} %mag is nx
				$ld \gets ||\mathcal{L}_{a}-\mathcal{L}_b||$ \tcp{calculate layout distance}
				$w_{ab} \gets \frac{1.0}{nd}$ \tcp{term weight} 
				$\mu \gets w_{ab}\eta$ \tcp{learning rate}  % current learning rate is given by term weight and step size
				\IF{$\mu>1$} {
				$\mu \gets 1$
				}
				$\delta \gets \mu \cdot \frac{ld -nd}{2}$ \tcp{the actual delta}
				\uIf{$\delta <= 0$} {
					$STOP$ \tcp{we can't optimize it any better, so we stop here}
				}
				% TODO stop early?
				% TODO potentially store new delta max?
				$r \gets \delta - ld$ \tcp{size of the term update}
				$\mathcal{L}_a \gets \mathcal{L}_a - r\cdot ld$ \tcp{update the 1. term}
				$\mathcal{L}_b \gets \mathcal{L}_b - r\cdot ld$ \tcp{update the 2. term}
			}
		}
	}
	\caption{Pseudocode of the PG-SGD algorithm. Explain $\eta$. Explain $PathIndex$ in the text. Explain $ZipfZetas$ in the text. Explain $RandomLayout$ in the text. Explain annealing schedule in the text or rephrase this wording.}
	\label{alg:pg_sgd}
\end{algorithm}